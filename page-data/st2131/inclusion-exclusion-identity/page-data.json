{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/st2131/inclusion-exclusion-identity","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"inclusion-exclusion-identity\"\n  }, \"Inclusion-Exclusion Identity\"), mdx(\"p\", null, \"Inclusion-Exclusion Identity:\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nP(E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 \\\\cup E_2 \\\\cup ... \\\\cup E_n) &= \\\\sum^n\"), \"{i = 1} P(E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i) \", \"\\\\\", \"\\n&- \\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 < i_2} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}) \", \"\\\\\", \"\\n&+ ... \", \"\\\\\", \"\\n&+ (-1)^{r + 1} \\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 < i_2 < ... < i_r} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}, ..., E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"r}) \", \"\\\\\", \"\\n&+ (-1)^{n + 1} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}, ..., E\"), \"{i_n})\\n\\\\end{aligned}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"If an outcome of the sample space is not a member of any of the set $E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i$, then its probability does not contribute anything to either side of the _addition law of exclusive events\"), \".\"), mdx(\"p\", null, \"Suppose that an outcome is in exactly $m$ of the events $E_i$, where $m > 0$,\\nand let the probability of the outcome be $w$, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is in $E_1 \\\\cup E_2 \\\\cup ... \\\\cup E_n$ and $w$ will be counted once in $P(E_1 \\\\cup E_2 \\\\cup ... \\\\cup E_n)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is in exactly $m$ of the events and $w$ will be counted exactly $\\\\binom{m}{1}$ times in $\\\\sum^n_{i = 1} P(E_i)$.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is contained in $\\\\binom{m}{2}$ subsets of the type $E\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{i_1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"2}$ and $w$ will be counted $\\\\binom{m}{2}$ times in $\\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1 < i_2} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1}, E\"), \"{i_2})$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"and so on.\")))), mdx(\"p\", null, \"Then \"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nw &= \\\\binom{m}{1} w - \\\\binom{m}{2} w + \\\\binom{m}{3}w - ... \\\\plusmn \\\\binom{m}{m}w \", \"\\\\\", \"\\n1 &= \\\\binom{m}{1} - \\\\binom{m}{2} + \\\\binom{m}{3}- ... \\\\plusmn \\\\binom{m}{m} \", \"\\\\\", \"\\n&\\\\binom{m}{0} - \\\\binom{m}{1} + \\\\binom{m}{2} - \\\\binom{m}{3} + ... \\\\plusmn \\\\binom{m}{m} = 0\\n\\\\end{aligned}\\n$$\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} (-1)^i = 0\\n$$\"), mdx(\"p\", null, \"Recall [\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }), \"binomial-theorem\"), \"],\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} x^i y^{m - i} = (x + y)^{m}\\n$$\"), mdx(\"p\", null, \"Let $x = -1$, $y = 1$,\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} (-1)^i = 0\\n$$\"), mdx(\"p\", null, \"Therefore \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#inclusion-exclusion-identity\"\n  }), \"the identity\"), \" is indeed true.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"binomial-theorem\"\n  }, \"Binomial Theorem\"), mdx(\"p\", null, \"$$(x + y)^n = \\\\sum^n_{k = 0} \\\\binom{n}{k} x^k y^{n - k}$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"By Mathematical Induction\"), mdx(\"h3\", {\n    \"id\": \"case-n--1\"\n  }, \"Case n = 1\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nLHS &= x + y \", \"\\\\\", \"\\nRHS &= \\\\binom{1}{0} y + \\\\binom{1}{1}x \", \"\\\\\", \"\\n\\\\therefore LHS &= RHS\\n\\\\end{aligned}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"application\"\n  }, \"Application\"), mdx(\"p\", null, \"How many subsets are there of a set consisting of $n$ elements?\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$2^n$\")), mdx(\"p\", null, \"$$(1 + 1)^n = \\\\sum_{k=0}^{n} \\\\binom{n}{k} = \\\\text{number of ways to form subset of size $k$}$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"4bc32513-25c9-519b-ae00-7f6ea40189ee","fields":{"slug":"/st2131/binomial-theorem","title":"Binomial Theorem"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"axioms-of-probability\"\n  }, \"Axioms of Probability\"), mdx(\"h2\", {\n    \"id\": \"preface\"\n  }, \"Preface\"), mdx(\"h3\", {\n    \"id\": \"sample-space\"\n  }, \"Sample Space\"), mdx(\"p\", null, \"Consider an experiment whose outcome is not predictable with certainty.\"), mdx(\"p\", null, \"The set of all possible outcomes of the experiment is known as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sample space\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Sample space can be uncountable (eg. age of a tree)\"), mdx(\"h3\", _extends({\n    parentName: \"blockquote\"\n  }, {\n    \"id\": \"event\"\n  }), \"Event\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any subset of a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#sample-space\"\n  }), \"sample space\"))), mdx(\"h3\", {\n    \"id\": \"laws-on-sets\"\n  }, \"Laws on Sets\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Commutative Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Associative Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Distributive Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"De Morgan's Laws\")), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"One way of defining the probability of an event is in terms of its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"relative frequency\"), \":\"), mdx(\"p\", null, \"$$ P(E) = \\\\lim_{n \\\\rightarrow \\\\inf} \\\\frac{n(E)}{n} $$\"), mdx(\"h3\", {\n    \"id\": \"problems-with-this-definition\"\n  }, \"Problems with this definition:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How do we konw that $\\\\frac{n(E)}{n}$ will converge?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How do we konw that $\\\\frac{n(E)}{n}$ will converge to the same if the experiment is repeatedly performed a second time?\")), mdx(\"h3\", {\n    \"id\": \"better-axioms\"\n  }, \"Better Axioms\"), mdx(\"p\", null, \"Consider an experiment whose sample space is $S$. For each event $E$ of the sample space $S$, we assume that a number $P(E)$ is defined and satisfies the following 3 [\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"axiom\",\n    \"title\": \"Axiom\"\n  }), \"axiom\"), \"]s:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$0 \\\\leq P(E) \\\\leq 1$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$P(S) = 1$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For any sequence of mutually exclusive events $E\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1, E_2, ...$, $$P(\\\\bigcup^{\\\\infty}\"), \"{i = 1} E(i)) = \\\\sum^{\\\\infty}_{i = 1} P(E_i)$$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The definitions of probability are mathematical definitions. They tell us which set functions can be called probability functions. They do not tell us the value of probability assigned to a given event.\")), mdx(\"h2\", {\n    \"id\": \"strong-law-of-large-numbers\"\n  }, \"Strong Law of Large Numbers\"), mdx(\"p\", null, \"If an experiment is repeated over and over again, then with probability 1, the proportion of time during which any specific event $E$ occurs will equal $P(E)$.\"), mdx(\"h2\", {\n    \"id\": \"inclusion-exclusion-identity\"\n  }, \"Inclusion-Exclusion Identity\"), mdx(\"p\", null, \"[\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"inclusion-exclusion-identity\",\n    \"title\": \"Inclusion-Exclusion Identity\"\n  }), \"inclusion-exclusion-identity\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"49f0af91-64c6-5e91-9c20-010d0dc1f658","fields":{"slug":"/st2131/axioms-of-probability","title":"Axioms of Probability"}}}]},"fields":{"slug":"/st2131/inclusion-exclusion-identity","title":"Inclusion-Exclusion Identity"}}},"pageContext":{"id":"bd2e3ebd-0d38-54ac-9ca9-51b482f3c5cb"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}