{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/distributed-dyom/gfs","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"google-file-system\"\n  }, \"Google File System\"), mdx(\"p\", null, \"[\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../journal/2021-01-17\",\n    \"title\": \"Sunday, January 17, 2021\"\n  }), \"2021-01-17\"), \"]\"), mdx(\"p\", null, \"#school #paper\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Original paper referenced \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pdos.csail.mit.edu/6.824/papers/gfs.pdf\"\n  }), \"here\"))), mdx(\"h2\", {\n    \"id\": \"motivation\"\n  }, \"Motivation\"), mdx(\"p\", null, \"Usage for Google's distributed file system defers from the traditional assumptions in the following ways:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Component failure are the norm rather than the exception.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Files are huge by traditional standards\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Most files are mutated by appending new data rather than overwriting existing data. Random writes within a file are practically non-existent.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Appending is the focus of performance optimization and atomicity guarantees\")))), mdx(\"h2\", {\n    \"id\": \"design-overview\"\n  }, \"Design Overview\"), mdx(\"h3\", {\n    \"id\": \"assumptions\"\n  }, \"Assumptions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"System must be able to constantly monitor itself, detect and tolerate and recover from failures on a routine basis.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"System is optimized for large, multi-GB files.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Small files are supported but not optimized for\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Workload primarily consist of:\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Large streaming reads\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Small random reads\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Small reads are batched together as large read by performance conscious applications anyway\"))))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Workload consist of large, sequential writes\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"System must efficiently implement well-defined semantics for multiple clients that concurrently append to the same file.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"High sustained bandwidth is more important than low latency.\")), mdx(\"h2\", {\n    \"id\": \"gfs-api\"\n  }, \"GFS API\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Support the usual \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"create\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"delete\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"open\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"close\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"read\"), \", \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"write\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Also provides \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"snapshot\"), \" and \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"record append\"), \".\")), mdx(\"h2\", {\n    \"id\": \"architecture\"\n  }, \"Architecture\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Single \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"master\"), \", multiple \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"chunkservers\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Accessed by multiple \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"clients\"), \".\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Neither the client nor the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"chunkservers\"), \" caches file data.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Client \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"do\"), \" cache metadata\")), mdx(\"h3\", {\n    \"id\": \"chunkserver\"\n  }, \"Chunkserver\"), mdx(\"p\", null, \"Files are divided into fixed-size chunks, each chunk is identified by an immutable and gloablly unique \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64-bit\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"chunk handle\"), \".\\nChunks are replicated on different chunkservers (replication level can be determined by user)\"), mdx(\"h3\", {\n    \"id\": \"single-master\"\n  }, \"Single Master\"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"master\"), \" \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"maintains all file system metadata\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"controls chunk lease management, garbage collection and chunk migration\")), mdx(\"p\", null, \"Polls \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"chunkservers\"), \" periodically to send instructions and collect state.\"), mdx(\"h4\", {\n    \"id\": \"shadow-masters\"\n  }, \"Shadow Masters\"), mdx(\"p\", null, \"Master state is replicated on other machines in order to achieve fault tolerance and high availability.\\nShadow masters lag slightly and may provide stale metadata, however, it allows clients to perform read operations even when the master is down to enhance read availability.\"), mdx(\"p\", null, \"It polls the master for operation log and applies the same mutations to its internal data structure.\"), mdx(\"h3\", {\n    \"id\": \"chunk-size\"\n  }, \"Chunk Size\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64mb\"), \" is much larger than typical file system block sizes.\"), mdx(\"p\", null, \"Large chunk size pros:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reduces client's need to interact with the master\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reduces network overhead by keeping a persistent connection to the chunkserver\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reduces the size of metadata\")), mdx(\"p\", null, \"Cons:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Small files that consist of only few chunks can become hotspots if many clients are accessing the same file.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"unlikely since most files are big\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"increase replication factor and stagger batch-queue system.\")))), mdx(\"h3\", {\n    \"id\": \"metadata\"\n  }, \"Metadata\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"File and chunk namespaces\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mapping from files to chunks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Locations of each chunk's replicas\")), mdx(\"p\", null, \"Namespaces and mappings are kept persistent by logging mutations to an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"operation log\"), \".\"), mdx(\"p\", null, \"Locations are requested from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"chunkservers\"), \" at startup and periodically after. This helps keep the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"master\"), \" in sync\"), mdx(\"h3\", {\n    \"id\": \"operation-log\"\n  }, \"Operation Log\"), mdx(\"p\", null, \"The operation log contains a historical record of critical metadata changes.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Changes are not made visible to clients until metadata changes are made persistent.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Log is replicated on multiple remote \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#shadow-masters\"\n  }), \"machines\"), \" \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A mutation to the state is considered committed only after its log record has been flushed to disk locally and on all master replicas.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Recovery needs only the latest complete checkpoint and subsequent log files.\")), mdx(\"h2\", {\n    \"id\": \"consistency-model\"\n  }, \"Consistency Model\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A file region is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"consistent\"), \" if all clients will always see the same data, regardless of which replicas they read from.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A region is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"defined\"), \" after a file data mutation if it is consistent and clients will see what the mutation writes in its entirety.\")), mdx(\"p\", null, \"File namespace mutations (creations) are atomic.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Singular successful mutation guarantees file region to be defined and consistent.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Concurrent successful mutations guarantees file region to be undefined but consistent.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A failed mutation makes the region inconsistent.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a record append fails at any replica, the client retries the operation. GFS only guarantees that the data is written at least once as an atomic unit.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Record prepared by the writer contains extra information like checksums so that its validity can be verified. Reader should handle padding and duplicates.\")))), mdx(\"h2\", {\n    \"id\": \"system-interactions\"\n  }, \"System Interactions\"), mdx(\"p\", null, \"Below I attempt to summarize the interactions during each GFS operation.\"), mdx(\"h3\", {\n    \"id\": \"create\"\n  }, \"Create\"), mdx(\"p\", null, \"Client acquires read-lock along the directory nodes and write-lock for the file being created.\"), mdx(\"p\", null, \"Subsequently client follows the same steps as in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#write\"\n  }), \"write\"), \".\"), mdx(\"h3\", {\n    \"id\": \"read\"\n  }, \"Read\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Client requests read operation with file name, chunk index from master.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Master acquires the necessary read-locks, replies client with chunk handle and location.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Client caches chunk handle, requests chunk from \\\"closest\\\" machine.\")), mdx(\"h3\", {\n    \"id\": \"write\"\n  }, \"Write\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Client asks the master which chunkserver holds the current lease for the chunk and the locations of the other replicas.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Master grants the lease if no chunkserver is holding the lease\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The master replies with the identity of the primary and the locations of the other replicas.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The client pushes the data to all replicas. \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Client sends a write request to the primary. \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Primary serializes the mutations and apply it to local state.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If an error occurs at the primary, mutations will not be assigned a serial number and write request will not be forwarded.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Primary forwards the write request to all secondary replicas.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The primary replies to the client after replicas report success. Any errors in the replica is also forwarded (request will be considered a failure).\")), mdx(\"h4\", {\n    \"id\": \"chunk-overflow\"\n  }, \"Chunk Overflow\"), mdx(\"p\", null, \"Primary checks to see if appending the record to the current chunk would cause teh chunk to exceed the maximum size.\\nIf so, it pads the chunk to the maximum size, tells secondaries to do the same, and replies to client indicating that the operation should be retried on the next chunk.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Record append is restricted to be at most $\\\\frac{1}{4}$ of the maximum chunk size to keep worst-case fragmentation at an acceptable level.\")), mdx(\"h4\", {\n    \"id\": \"dataflow\"\n  }, \"Dataflow\"), mdx(\"p\", null, \"Data is pushed linearly along a chain of chunkservers rather than distributed in some other topology.\\nEach machine's full outbound bandwidth is used to transfer the data as fast as possible rather than divided among multiple recipients.\"), mdx(\"p\", null, \"Each machine forwards the data to the \\\"closest\\\" machine in the network topology that have not received it.\"), mdx(\"h5\", {\n    \"id\": \"pipelining\"\n  }, \"Pipelining\"), mdx(\"p\", null, \"Once a chunkserver receives some data, it starts forwarding immediately. Useful in switched network with full-duplex links.\"), mdx(\"p\", null, \"Without network congestion, the ideal elapsed time for transferring $B$ bytes to $R$ replicas is $B/T + RL$ where $T$ is the network throughput and $L$ is latency to transfer bytes between two machines.\"), mdx(\"h3\", {\n    \"id\": \"delete\"\n  }, \"Delete\"), mdx(\"p\", null, \"Deletion happens lazily and storage space is reclaimed from garbage collection.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Master logs deletion immediately.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"File is renamed to a hidden name that includes the deletion timestamp.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"File is properly removed if it has existed for more than \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"some configurable interval\"), \", during master's regular scan.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Master removes in-memory metadata of hidden file.\")))), mdx(\"p\", null, \"In regular scan of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"chunk namespace\"), \", the master identifies orphaned chunks and erases the metadata for those chunks.\"), mdx(\"p\", null, \"In \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"HeartBeat\"), \" messages exchanged with the master, each chunkserver reports a subset of the chunks it has, and the master replies with the identity of all chunks that are no longer present in the master's metadata.\\nThe chunkserver is free to delete its replicas of such chunks.\"), mdx(\"h3\", {\n    \"id\": \"snapshot\"\n  }, \"Snapshot\"), mdx(\"p\", null, \"Snapshots are implemented using standard copy-on-write techniques.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Master revokes any outstanding leases on the chunks that are about to be snapshot.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Master commits snapshot into its operation log\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Metadata for the source file or directory tree is duplicated.\")), mdx(\"p\", null, \"For write to some snapshot chunk $C$, master notices that the reference count for chunk $C$ is greater than one.\\nIt defers replying to the client request and instead picks a new chunk handle $C'$.\\nIt then asks each chunkserver with $C$ to create copy $C'$ locally.\"), mdx(\"h2\", {\n    \"id\": \"fault-tolerance\"\n  }, \"Fault Tolerance\"), mdx(\"h1\", {\n    \"id\": \"discussion-questions\"\n  }, \"Discussion Questions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When does GFS choose \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"write append\"), \" vs \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"record append\"), \"?\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"write append -> non-concurrent ?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"record append -> concurrent ?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Who decides?\")))));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"distributed-systems\"\n  }, \"Distributed Systems\"), mdx(\"p\", null, \"#entry\"), mdx(\"h2\", {\n    \"id\": \"week-2-google-file-system\"\n  }, \"Week 2: Google File System\"), mdx(\"p\", null, \"[\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"gfs\",\n    \"title\": \"Google File System\"\n  }), \"gfs\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"14f7242e-6dbb-57e6-81a6-d73cb80db295","fields":{"slug":"/distributed-dyom/distributed-dyom","title":"Distributed Systems"}}}]},"fields":{"slug":"/distributed-dyom/gfs","title":"Google File System"}}},"pageContext":{"id":"61ee9891-99e9-55f0-9c1a-8851f9082b98"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}